<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ESMA-Leitlinien f√ºr Fondsnamen: Was ‚Äûnachhaltige‚Äú Fonds ge√§ndert haben</title>
  <meta property="og:title" content="ESMA-Leitlinien f√ºr Fondsnamen: Was ‚Äûnachhaltige‚Äú Fonds ge√§ndert haben" />
  <meta property="og:description" content="Diese Grafik betrachtet nur Fonds mit Begriffen wie Nachhaltigkeit, Umwelt oder Impact im Namen. Nach den ESMA-Leitlinien d√ºrfen diese Fonds keine Unternehmen im Portfolio haben, die nach der Paris-aligned Benchmark (PAB) ausgeschlossen sind. Die Grafik zeigt, was sich ver√§ndert hat." />
  <meta property="og:image" content="https://alisonschultz.github.io/esma/title_pic.png" />
  <meta property="og:url" content="https://alisonschultz.github.io/esma/" />

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/d3-sankey@0.12.3"></script>

  <style>
    body {
      font-family: Verdana, sans-serif;
      margin: 0; padding: 0;
      display: flex; flex-direction: column;
      align-items: center; height: 100vh;
    }

    #controls {
      margin: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    #controls label { font-size: 14px; margin-right: 6px; }
    #controls select { font-size: 14px; padding: 4px 6px; font-family: Verdana, sans-serif; }

    #chartWrap {
      width: 100%;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #chart { flex: 1; width: 100%; }
    svg { width: 100%; height: 100%; }

    /* dezentere Download-Buttons unter dem Chart */
    #downloads {
      margin: 6px 0 12px;
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }
    #downloads button {
      font-size: 12px;
      padding: 4px 10px;
      font-family: Verdana, sans-serif;
      cursor: pointer;
      background: #f5f5f5;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      color: #333;
    }
    #downloads button:hover {
      background: #eeeeee;
    }

    .link { fill: none; stroke-opacity: 0.5; transition: stroke-opacity 0.2s; }
    .link.highlight { stroke-opacity: 0.9; }
    .dimmed .link:not(.highlight) { stroke-opacity: 0.3; }

    .node rect { opacity: 0.6; transition: opacity 0.2s; }
    .node.highlight rect { opacity: 1 !important; }
    .dimmed .node rect:not(.highlight) { opacity: 0.3; }

    .tooltip {
      position: absolute; background: lightgrey;
      padding: 6px; border-radius: 4px;
      pointer-events: none; opacity: 0;
      transition: opacity 0.2s;
    }

    .header {
      width: min(1100px, calc(100% - 48px));
      margin: 18px auto 6px;
      text-align: center;
    }
    .header h1 { margin: 0 0 6px; font-size: 20px; }
    .header p { margin: 0 0 12px; font-size: 14px; line-height: 1.4; }
  </style>
</head>

<body>
  <div class="header">
    <h1>ESMA-Leitlinien f√ºr Fondsnamen: Was &raquo;nachhaltige&laquo; Fonds ge√§ndert haben</h1>
    <p>
      Diese Grafik betrachtet Fonds, die Begriffe wie <b>Nachhaltigkeit</b>, <b>Umwelt</b> oder <b>Impact</b> im Namen trugen.
      F√ºr diese Fonds gelten nach den ESMA-Leitlinien strengere Mindestanforderungen: Bestimmte Unternehmen, die nach der
      <b>Paris-aligned Benchmark (PAB)</b> ausgeschlossen sind, d√ºrfen nicht mehr im Portfolio enthalten sein.
      Die Sankey-Grafik zeigt, wie sich die Investitionen vor und nach den Leitlinien ver√§ndert haben.<br>
      üìÑ <a href="https://isitchristmas.com/" target="_blank" style="text-decoration: none; color: #006699;">
        Zur Studie (Hintergrund &amp; Methodik [bisher noch random Link])
      </a>
    </p>
  </div>

  <div id="controls">
    <label for="amSelect">Investments:</label>
    <select id="amSelect">
      <option value="esi_pab">Firmen, die gegen die Paris-aligned Benchmark (PAB) versto√üen</option>
      <option value="esi_gogcel" selected>Alle Firmen von urgewalds Global Coal Exit List und Global Oil and Gas Exit List</option>
      <option value="esi_expansion">Firmen, die ihre fossilen Aktivit√§ten ausbauen</option>
      <option value="esi_expansion_coal_expansion">Firmen mit Kohle-Expansion</option>
      <option value="esi_expansion_short_term_expansion_20_mmboe">Firmen mit kurzfristiger Expansionsaktivit√§t</option>
      <option value="esi_expansion_pipeline_expansion_100_km">Firmen mit Pipeline-Expansion</option>
      <option value="esi_expansion_lng_expansion_1_mtpa">Firmen mit LNG-Expansion</option>
      <option value="esi_expansion_gas_fired_power_expansion_100_mw">Firmen mit Ausbau von Gaskraftwerken</option>
      <option value="esi_expansion_oil_fired_power_expansion_100_mw">Firmen mit Ausbau von √ñlkraftwerken</option>
    </select>
  </div>

  <div id="chartWrap">
    <div id="chart"></div>

    <div id="downloads" aria-label="downloads">
      <button id="btnSvg" type="button">SVG herunterladen</button>
      <button id="btnPng" type="button">PNG herunterladen</button>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ---------- dimensions (extra space left/right for outside labels) ----------
    const margin = { top: 40, right: 330, bottom: 40, left: 260 };
    const fullW = 1240, fullH = 500;
    const width  = fullW  - margin.left - margin.right;
    const height = fullH  - margin.top  - margin.bottom;

    const order = [
      "left_fossil",
      "right_esi",
      "right_renamed",
      "right_divested",
    ];

    // Labels (two lines for the long ones)
    const labels = {
      left_fossil:   ["Ausgangsbestand"],
      right_esi:     ["Weiterhin investiert,", "Fondsname unver√§ndert"],
      right_renamed: ["Weiterhin investiert,", "Fondsname ge√§ndert"],
      right_divested:["Verkauft"],
    };

    const fmtDE = new Intl.NumberFormat("de-DE", {
      minimumFractionDigits: 0,
      maximumFractionDigits: 1
    });

    function labelLines(name) {
      return labels[name] ? labels[name].slice() : [name];
    }

    function formatMio(v) {
      return `${fmtDE.format(v)} Mil. ‚Ç¨`;
    }

    // ---------- SVG setup ----------
    const svgRoot = d3.select("#chart")
      .append("svg")
        .attr("viewBox", `0 0 ${fullW} ${fullH}`)
        .attr("preserveAspectRatio", "xMinYMin meet")
        // IMPORTANT: bake the font into the SVG so exports keep it
        .attr("font-family", "Verdana, sans-serif");

    const svg = svgRoot.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const tooltip = d3.select("#tooltip");
    let currentPrefix = d3.select("#amSelect").property("value");

    function positionTooltip(e) {
      const tt = tooltip.node();
      const padding = 6;
      const tooltipWidth = tt.offsetWidth || 150;

      let x = e.pageX + padding;
      if (e.pageX + tooltipWidth + 2 * padding > window.innerWidth) {
        x = e.pageX - tooltipWidth - padding;
      }
      tooltip.style("left", x + "px").style("top", (e.pageY - 6) + "px");
    }

    function setMultilineText(textSel, lines, x, lineDy = 1.15) {
      textSel.selectAll("tspan").remove();
      lines.forEach((line, i) => {
        textSel.append("tspan")
          .attr("x", x)
          .attr("dy", i === 0 ? 0 : `${lineDy}em`)
          .text(line);
      });
    }

    function loadChart(prefix) {
      currentPrefix = prefix;
      svg.selectAll("*").remove();

      const sankeyGen = d3.sankey()
        .nodeWidth(20)
        .nodePadding(10)
        .extent([[1,1],[width-1,height-1]])
        .nodeAlign(d3.sankeyJustify)
        .nodeSort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));

      Promise.all([
        d3.csv(`${prefix}_nodes.csv`),
        d3.csv(`${prefix}_links.csv`)
      ]).then(([nodesRaw, linksRaw]) => {
        const N = nodesRaw.length;

        // duplicate nodes left/right + carry extra field
        const sankeyNodes = nodesRaw
          .map(d => ({
            name: (d.kategorie || "").trim(),
            color: d.color,
            col: "L",
            preisbereinigt: +d.preisbereinigt_mio
          }))
          .concat(
            nodesRaw.map(d => ({
              name: (d.kategorie || "").trim(),
              color: d.color,
              col: "R",
              preisbereinigt: +d.preisbereinigt_mio
            }))
          );

        const sankeyLinks = linksRaw
          .map(d => {
            const s = nodesRaw.findIndex(n => (n.kategorie || "").trim() === (d.source_kategorie || "").trim());
            const t = nodesRaw.findIndex(n => (n.kategorie || "").trim() === (d.target_kategorie || "").trim());
            return (s < 0 || t < 0) ? null : { source: s, target: N + t, value: +d.value };
          })
          .filter(d => d);

        const { nodes: Gnodes, links: Glinks } = sankeyGen({ nodes: sankeyNodes, links: sankeyLinks });
        const visibleNodes = Gnodes.filter(d => d.value > 0);

        // gradients
        const defs = svg.append("defs");
        Glinks.forEach((link,i) => {
          const grad = defs.append("linearGradient")
            .attr("id", `grad${i}`)
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", link.source.x1)
            .attr("x2", link.target.x0);

          grad.append("stop").attr("offset","0%")
            .attr("stop-color", sankeyNodes[link.source.index].color);

          grad.append("stop").attr("offset","100%")
            .attr("stop-color", sankeyNodes[link.target.index].color);
        });

        // links (tooltip only)
        svg.append("g")
          .selectAll("path")
          .data(Glinks)
          .enter().append("path")
            .attr("class","link")
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("stroke-width", d => Math.max(1, d.width))
            .attr("stroke", (d,i) => `url(#grad${i})`)
            .on("mouseover",(e,d)=>{
              svg.classed("dimmed",true);
              d3.select(e.currentTarget).classed("highlight",true);
              tooltip.style("opacity",1).html(`${formatMio(d.value)}`);
              positionTooltip(e);
            })
            .on("mousemove", positionTooltip)
            .on("mouseout",()=>{
              svg.classed("dimmed",false);
              d3.selectAll(".link").classed("highlight",false);
              tooltip.style("opacity",0);
            });

        // headings
        const leftNodes  = visibleNodes.filter(d => d.col === "L");
        const rightNodes = visibleNodes.filter(d => d.col === "R");
        const leftX  = d3.min(leftNodes,  d => d.x0);
        const rightX = d3.max(rightNodes, d => d.x1);

        svg.append("text")
          .attr("class", "col-heading")
          .attr("x", leftX)
          .attr("y", -15)
          .attr("text-anchor", "start")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .text("Vor ESMA-Leitlinien");

        svg.append("text")
          .attr("class", "col-heading")
          .attr("x", rightX - 6)
          .attr("y", -15)
          .attr("text-anchor", "end")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .text("Aktuellstes Portfolio");

        // nodes (tooltip only)
        const node = svg.append("g")
          .selectAll("g")
          .data(visibleNodes)
          .enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x0},${d.y0})`)
            .on("mouseover",(e,d)=>{
              svg.classed("dimmed",true);
              d3.select(e.currentTarget).classed("highlight",true);

              let html = `${labelLines(d.name).join(" ")}: ${formatMio(d.value)}`;
              if (d.col === "R" && d.name === "right_divested" && Number.isFinite(d.preisbereinigt)) {
                html += `<br><span>Preisbereinigt: ${formatMio(d.preisbereinigt)}</span>`;
              }
              tooltip.style("opacity",1).html(html);
              positionTooltip(e);
            })
            .on("mousemove", positionTooltip)
            .on("mouseout",()=>{
              svg.classed("dimmed",false);
              d3.selectAll(".node").classed("highlight",false);
              tooltip.style("opacity",0);
            });

        node.append("rect")
          .attr("width", sankeyGen.nodeWidth())
          .attr("height", d => d.y1 - d.y0)
          .attr("fill", d => d.color);

        // OUTSIDE LABELS (online: no numbers)
        const labelsLayer = svg.append("g").attr("class", "outside-labels");

        labelsLayer.selectAll("text")
          .data(visibleNodes)
          .enter().append("text")
            .attr("class", "outside-label")
            .attr("x", d => (d.col === "L" ? -12 : width + 12))
            .attr("y", d => (d.y0 + d.y1) / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", d => (d.col === "L" ? "end" : "start"))
            .style("font-size", "12px")
            .attr("data-name", d => d.name)
            .attr("data-col", d => d.col)
            .attr("data-value", d => d.value)
            .attr("data-preisbereinigt", d => Number.isFinite(d.preisbereinigt) ? d.preisbereinigt : "")
            .each(function(d) {
              const x = (d.col === "L") ? -12 : (width + 12);
              setMultilineText(d3.select(this), labelLines(d.name), x);
            });

      })
      .catch(err => console.error("Failed to load CSVs or build sankey:", err));
    }

    // ---------- Export helpers ----------
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function injectExportStyles(svgElClone) {
      // ensure font + bold heading class survive outside the browser CSS
      svgElClone.setAttribute("font-family", "Verdana, sans-serif");

      const styleEl = document.createElementNS("http://www.w3.org/2000/svg", "style");
      styleEl.textContent = `
        text { font-family: Verdana, sans-serif; }
        .col-heading { font-weight: 700; }
      `;
      svgElClone.insertBefore(styleEl, svgElClone.firstChild);
    }

    function inlineComputedStyles(svgEl) {
      const all = svgEl.querySelectorAll("*");
      all.forEach(el => {
        const cs = getComputedStyle(el);
        let style = "";
        for (const prop of cs) style += `${prop}:${cs.getPropertyValue(prop)};`;
        el.setAttribute("style", style);
      });
    }

    // Put numbers AFTER the entire label (last line), not after first line
    function addNumbersToClonedSVG(svgElClone) {
      const labelTexts = svgElClone.querySelectorAll("text.outside-label");

      labelTexts.forEach(t => {
        const name = t.getAttribute("data-name");
        const col = t.getAttribute("data-col");
        const value = Number(t.getAttribute("data-value"));
        const pbRaw = t.getAttribute("data-preisbereinigt");
        const preisbereinigt = pbRaw === "" ? NaN : Number(pbRaw);

        const tspans = t.querySelectorAll("tspan");
        if (tspans.length === 0) return;

        // Append ": X" to the LAST line of the label
        const last = tspans[tspans.length - 1];
        const lineLast = last.textContent || "";
        last.textContent = `${lineLast}: ${formatMio(value)}`;

        // Add Preisbereinigt line for right_divested on right
        if (col === "R" && name === "right_divested" && Number.isFinite(preisbereinigt)) {
          const x = last.getAttribute("x") || tspans[0].getAttribute("x");
          const tspanPB = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspanPB.setAttribute("x", x);
          tspanPB.setAttribute("dy", "1.15em");
          tspanPB.style.fontSize = "10px";
          tspanPB.textContent = `Preisbereinigt: ${formatMio(preisbereinigt)}`;
          t.appendChild(tspanPB);
        }
      });

      // Ensure headings are bold (even if styles get lost)
      svgElClone.querySelectorAll("text.col-heading").forEach(h => {
        h.style.fontWeight = "700";
      });
    }

    function serializeSVG(svgEl) {
      const serializer = new XMLSerializer();
      let source = serializer.serializeToString(svgEl);

      if (!source.match(/^<svg[^>]+xmlns=/)) {
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
      }
      if (!source.match(/^<svg[^>]+"http:\/\/www.w3.org\/1999\/xlink"/)) {
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
      }
      return source;
    }

    function downloadSVGWithNumbers(filename) {
      const svgEl = d3.select("#chart").select("svg").node();
      const clone = svgEl.cloneNode(true);

      // Set explicit pixel size so SVG viewers don't default weirdly
      const rect = svgEl.getBoundingClientRect();
      clone.setAttribute("width", rect.width);
      clone.setAttribute("height", rect.height);

      injectExportStyles(clone);
      inlineComputedStyles(clone);
      addNumbersToClonedSVG(clone);

      const source = serializeSVG(clone);
      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      downloadBlob(blob, filename);
    }

    function downloadPNGWithNumbers(filename, scale = 4) {
      const svgEl = d3.select("#chart").select("svg").node();
      const clone = svgEl.cloneNode(true);

      // Use viewBox size as "natural size" for rasterization
      const vb = svgEl.viewBox && svgEl.viewBox.baseVal ? svgEl.viewBox.baseVal : null;
      const w = vb ? vb.width : 1240;
      const h = vb ? vb.height : 500;

      clone.setAttribute("width", w);
      clone.setAttribute("height", h);

      injectExportStyles(clone);
      inlineComputedStyles(clone);
      addNumbersToClonedSVG(clone);

      const svgString = serializeSVG(clone);
      const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = Math.round(w * scale);
        canvas.height = Math.round(h * scale);

        const ctx = canvas.getContext("2d");
        // white background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw scaled image
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        canvas.toBlob(blob => {
          downloadBlob(blob, filename);
          URL.revokeObjectURL(url);
        }, "image/png");
      };

      img.onerror = (e) => {
        console.error("PNG export failed", e);
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }

    // ---------- wire up ----------
    d3.select("#amSelect").on("change", function() {
      loadChart(this.value);
    });

    document.getElementById("btnSvg").addEventListener("click", () => {
      downloadSVGWithNumbers(`sankey_${currentPrefix}.svg`);
    });

    document.getElementById("btnPng").addEventListener("click", () => {
      downloadPNGWithNumbers(`sankey_${currentPrefix}.png`, 4);
    });

    // initial draw
    loadChart(d3.select("#amSelect").property("value"));
  </script>
</body>
</html>
