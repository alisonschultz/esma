<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ESMA-Leitlinien f√ºr Fondsnamen: Was ‚Äûnachhaltige‚Äú Fonds ge√§ndert haben</title>
  <meta property="og:title" content="ESMA-Leitlinien f√ºr Fondsnamen: Was ‚Äûnachhaltige‚Äú Fonds ge√§ndert haben" />
  <meta property="og:description" content="Diese Grafik betrachtet nur Fonds mit Begriffen wie Nachhaltigkeit, Umwelt oder Impact im Namen. Nach den ESMA-Leitlinien d√ºrfen diese Fonds keine Unternehmen im Portfolio haben, die nach der Paris-aligned Benchmark (PAB) ausgeschlossen sind. Die Grafik zeigt, was sich ver√§ndert hat." />
  <meta property="og:image" content="https://alisonschultz.github.io/esma/title_pic.png" />
  <meta property="og:url" content="https://alisonschultz.github.io/esma/" />

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/d3-sankey@0.12.3"></script>

  <style>
    body {
      font-family: Verdana, sans-serif;
      margin: 0; padding: 0;
      display: flex; flex-direction: column;
      align-items: center; height: 100vh;
    }

    #controls {
      margin: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    #controls label { font-size: 14px; margin-right: 6px; }
    #controls select { font-size: 14px; padding: 4px 6px; font-family: Verdana, sans-serif; }

    #chartWrap {
      width: 100%;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #chart { flex: 1; width: 100%; }
    svg { width: 100%; height: 100%; }

    #downloads {
      margin: 6px 0 12px;
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }
    #downloads button {
      font-size: 12px;
      padding: 4px 10px;
      font-family: Verdana, sans-serif;
      cursor: pointer;
      background: #f5f5f5;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      color: #333;
    }
    #downloads button:hover { background: #eeeeee; }

    .link { fill: none; stroke-opacity: 0.5; transition: stroke-opacity 0.2s; }
    .link.highlight { stroke-opacity: 0.9; }
    .dimmed .link:not(.highlight) { stroke-opacity: 0.3; }

    .node rect { opacity: 0.6; transition: opacity 0.2s; }
    .node.highlight rect { opacity: 1 !important; }
    .dimmed .node rect:not(.highlight) { opacity: 0.3; }

    .tooltip {
      position: absolute; background: lightgrey;
      padding: 6px; border-radius: 4px;
      pointer-events: none; opacity: 0;
      transition: opacity 0.2s;
    }

    .header {
      width: min(1100px, calc(100% - 48px));
      margin: 18px auto 6px;
      text-align: center;
    }
    .header h1 { margin: 0 0 6px; font-size: 20px; }
    .header p { margin: 0 0 12px; font-size: 14px; line-height: 1.4; }
  </style>
</head>

<body>
  <div class="header">
    <h1>ESMA-Leitlinien f√ºr Fondsnamen: Was &raquo;nachhaltige&laquo; Fonds ge√§ndert haben</h1>
    <p>
      Diese Grafik betrachtet Fonds, die Begriffe wie <b>Nachhaltigkeit</b>, <b>Umwelt</b> oder <b>Impact</b> im Namen trugen.
      F√ºr diese Fonds gelten nach den ESMA-Leitlinien strengere Mindestanforderungen: Bestimmte Unternehmen, die nach der
      <b>Paris-aligned Benchmark (PAB)</b> ausgeschlossen sind, d√ºrfen nicht mehr im Portfolio enthalten sein.
      Die Sankey-Grafik zeigt, wie sich die Investitionen vor und nach den Leitlinien ver√§ndert haben.<br>
      üìÑ <a href="https://isitchristmas.com/" target="_blank" style="text-decoration: none; color: #006699;">
        Zur Studie (Hintergrund &amp; Methodik [bisher noch random Link])
      </a>
    </p>
  </div>

  <div id="controls">
    <label for="amSelect">Investments:</label>
    <select id="amSelect">
      <option value="esi_pab">Firmen, die gegen die Paris-aligned Benchmark (PAB) versto√üen</option>
      <option value="esi_gogcel" selected>Alle Firmen von urgewalds Global Coal Exit List und Global Oil and Gas Exit List</option>
      <option value="esi_expansion">Firmen, die ihre fossilen Aktivit√§ten ausbauen</option>
      <option value="esi_expansion_coal_expansion">Firmen mit Kohle-Expansion</option>
      <option value="esi_expansion_short_term_expansion_20_mmboe">Firmen mit kurzfristiger Expansionsaktivit√§t</option>
      <option value="esi_expansion_pipeline_expansion_100_km">Firmen mit Pipeline-Expansion</option>
      <option value="esi_expansion_lng_expansion_1_mtpa">Firmen mit LNG-Expansion</option>
      <option value="esi_expansion_gas_fired_power_expansion_100_mw">Firmen mit Ausbau von Gaskraftwerken</option>
      <option value="esi_expansion_oil_fired_power_expansion_100_mw">Firmen mit Ausbau von √ñlkraftwerken</option>
    </select>
  </div>

  <div id="chartWrap">
    <div id="chart"></div>

    <div id="downloads" aria-label="downloads">
      <button id="btnSvg" type="button">SVG herunterladen</button>
      <button id="btnPng" type="button">PNG herunterladen</button>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ---------- dimensions ----------
    const margin = { top: 40, right: 330, bottom: 40, left: 260 };
    const fullW = 1240, fullH = 500;
    const width  = fullW  - margin.left - margin.right;
    const height = fullH  - margin.top  - margin.bottom;

    const order = ["left_fossil", "right_esi", "right_renamed", "right_divested"];

    // Base labels (divested gets replaced to Zugekauft when needed)
    const labels = {
      left_fossil:   ["Ausgangsbestand"],
      right_esi:     ["Weiterhin investiert,", "Fondsname unver√§ndert"],
      right_renamed: ["Weiterhin investiert,", "Fondsname ge√§ndert"],
      right_divested:["Divestment"],
      right_bought:  ["Zugekauft"], // used when divested is negative
    };

    // German number formatting
    const fmtDE = new Intl.NumberFormat("de-DE", {
      maximumFractionDigits: 0
    });


    function formatMio(v) {
      return `${fmtDE.format(v)} Mil. ‚Ç¨`;
    }

    function labelLines(name, isBuy = false) {
      if (name === "right_divested" && isBuy) return labels.right_bought.slice();
      return labels[name] ? labels[name].slice() : [name];
    }

    // SVG setup
    const svgRoot = d3.select("#chart")
      .append("svg")
        .attr("viewBox", `0 0 ${fullW} ${fullH}`)
        .attr("preserveAspectRatio", "xMinYMin meet");

    const svg = svgRoot.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const tooltip = d3.select("#tooltip");
    let currentPrefix = d3.select("#amSelect").property("value");

    function positionTooltip(e) {
      const tt = tooltip.node();
      const padding = 6;
      const tooltipWidth = tt.offsetWidth || 150;

      let x = e.pageX + padding;
      if (e.pageX + tooltipWidth + 2 * padding > window.innerWidth) {
        x = e.pageX - tooltipWidth - padding;
      }
      tooltip.style("left", x + "px").style("top", (e.pageY - 6) + "px");
    }

    // NEW: vertically center a multi-line label around y by shifting the first line upward
    function setMultilineTextCentered(textSel, lines, x, lineDy = 1.15) {
      textSel.selectAll("tspan").remove();
      const n = lines.length;
      const firstDy = (n <= 1) ? 0 : (-(n - 1) / 2) * lineDy;

      lines.forEach((line, i) => {
        textSel.append("tspan")
          .attr("x", x)
          .attr("dy", i === 0 ? `${firstDy}em` : `${lineDy}em`)
          .text(line);
      });
    }

    function loadChart(prefix) {
      currentPrefix = prefix;
      svg.selectAll("*").remove();

      const sankeyGen = d3.sankey()
        .nodeWidth(20)
        .nodePadding(10)
        .extent([[1,1],[width-1,height-1]])
        .nodeAlign(d3.sankeyJustify)
        .nodeSort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));

      Promise.all([
        d3.csv(`${prefix}_nodes.csv`),
        d3.csv(`${prefix}_links.csv`)
      ]).then(([nodesRaw, linksRaw]) => {
        const N = nodesRaw.length;

        // Map: display_mio per category
        const displayByName = new Map(
          nodesRaw.map(d => [String(d.kategorie || "").trim(), +d.display_mio])
        );

        // Determine if divested is "buy" based on LINKS value (signed)
        const divLink = linksRaw.find(d => String(d.target_kategorie || "").trim() === "right_divested");
        const divIsBuy = divLink ? (+divLink.value < 0) : false;

        // Build sankey nodes (duplicate left/right)
        const sankeyNodes = nodesRaw
          .map(d => ({
            name: String(d.kategorie || "").trim(),
            color: d.color,
            col: "L",
            display: +d.display_mio
          }))
          .concat(
            nodesRaw.map(d => ({
              name: String(d.kategorie || "").trim(),
              color: d.color,
              col: "R",
              display: +d.display_mio
            }))
          );

        // Build links: abs() for geometry; keep signed for logic
        const sankeyLinks = linksRaw
          .map(d => {
            const sName = String(d.source_kategorie || "").trim();
            const tName = String(d.target_kategorie || "").trim();
            const s = nodesRaw.findIndex(n => String(n.kategorie || "").trim() === sName);
            const t = nodesRaw.findIndex(n => String(n.kategorie || "").trim() === tName);
            if (s < 0 || t < 0) return null;

            const signed = +d.value;
            return {
              source: s,
              target: N + t,
              value: Math.abs(signed),   // geometry
              signedValue: signed,       // logic
              targetName: tName
            };
          })
          .filter(Boolean);

        // If divested is negative (=buy), recolor that link + node to brown
        if (divIsBuy) {
          const brown = "#5A3C2E";
          sankeyLinks.forEach(L => { if (L.targetName === "right_divested") L._forceColor = brown; });
          sankeyNodes.forEach(n => { if (n.name === "right_divested") n.color = brown; });
        }

        const { nodes: Gnodes, links: Glinks } = sankeyGen({ nodes: sankeyNodes, links: sankeyLinks });
        const visibleNodes = Gnodes.filter(d => d.value > 0);

        // Gradients
        const defs = svg.append("defs");
        Glinks.forEach((link,i) => {
          const srcColor = sankeyNodes[link.source.index].color;
          const tgtColor = link._forceColor || sankeyNodes[link.target.index].color;

          const grad = defs.append("linearGradient")
            .attr("id", `grad${i}`)
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", link.source.x1)
            .attr("x2", link.target.x0);

          grad.append("stop").attr("offset","0%").attr("stop-color", srcColor);
          grad.append("stop").attr("offset","100%").attr("stop-color", tgtColor);
        });

        // Links (tooltip only)
        svg.append("g")
          .selectAll("path")
          .data(Glinks)
          .enter().append("path")
            .attr("class","link")
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("stroke-width", d => Math.max(1, d.width))
            .attr("stroke", (d,i) => `url(#grad${i})`)
            .on("mouseover",(e,d)=>{
              svg.classed("dimmed",true);
              d3.select(e.currentTarget).classed("highlight",true);

              const signed = (d.signedValue !== undefined) ? d.signedValue : d.value;
              tooltip.style("opacity",1).html(`${formatMio(Math.abs(signed))}`);
              positionTooltip(e);
            })
            .on("mousemove", positionTooltip)
            .on("mouseout",()=>{
              svg.classed("dimmed",false);
              d3.selectAll(".link").classed("highlight",false);
              tooltip.style("opacity",0);
            });

        // Headings (bold)
        const leftNodes  = visibleNodes.filter(d => d.col === "L");
        const rightNodes = visibleNodes.filter(d => d.col === "R");
        const leftX  = d3.min(leftNodes,  d => d.x0);
        const rightX = d3.max(rightNodes, d => d.x1);

        svg.append("text")
          .attr("class", "col-heading")
          .attr("x", leftX)
          .attr("y", -15)
          .attr("text-anchor", "start")
          .style("font-size", "12px")
          .style("font-weight", "700")
          .text("Vor ESMA-Leitlinien");

        svg.append("text")
          .attr("class", "col-heading")
          .attr("x", rightX - 6)
          .attr("y", -15)
          .attr("text-anchor", "end")
          .style("font-size", "12px")
          .style("font-weight", "700")
          .text("Aktuellstes Portfolio");

        // Nodes (tooltip only)
        const node = svg.append("g")
          .selectAll("g")
          .data(visibleNodes)
          .enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x0},${d.y0})`)
            .on("mouseover",(e,d)=>{
              svg.classed("dimmed",true);
              d3.select(e.currentTarget).classed("highlight",true);

              const isBuy = (d.name === "right_divested" && divIsBuy);
              const shownLabel = labelLines(d.name, isBuy).join(" ");
              const displayVal = Number.isFinite(d.display) ? d.display : Math.abs(d.value);

              tooltip.style("opacity",1).html(`${shownLabel}: ${formatMio(Math.abs(displayVal))}`);
              positionTooltip(e);
            })
            .on("mousemove", positionTooltip)
            .on("mouseout",()=>{
              svg.classed("dimmed",false);
              d3.selectAll(".node").classed("highlight",false);
              tooltip.style("opacity",0);
            });

        node.append("rect")
          .attr("width", sankeyGen.nodeWidth())
          .attr("height", d => d.y1 - d.y0)
          .attr("fill", d => d.color);

        // OUTSIDE LABELS (browser: label only)
        const labelsLayer = svg.append("g").attr("class", "outside-labels");

        labelsLayer.selectAll("text")
          .data(visibleNodes)
          .enter().append("text")
            .attr("class", "outside-label")
            .attr("x", d => (d.col === "L" ? -12 : width + 12))
            .attr("y", d => (d.y0 + d.y1) / 2)
            .attr("text-anchor", d => (d.col === "L" ? "end" : "start"))
            .attr("dominant-baseline", "middle")
            .style("font-family", "Verdana, sans-serif")
            .style("font-size", "12px")
            .attr("data-name", d => d.name)
            .attr("data-col", d => d.col)
            .attr("data-display", d => {
              const v = displayByName.get(d.name);
              return Number.isFinite(v) ? v : Math.abs(d.value);
            })
            .attr("data-isbuy", d => (d.name === "right_divested" && divIsBuy) ? "1" : "0")
            .each(function(d) {
              const x = (d.col === "L") ? -12 : (width + 12);
              const isBuy = (d.name === "right_divested" && divIsBuy);
              setMultilineTextCentered(d3.select(this), labelLines(d.name, isBuy), x);
            });
      })
      .catch(err => console.error("Failed to load CSVs or build sankey:", err));
    }

    // ---------- Export helpers ----------
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function injectExportStyles(svgElClone) {
      svgElClone.setAttribute("font-family", "Verdana, sans-serif");
      const styleEl = document.createElementNS("http://www.w3.org/2000/svg", "style");
      styleEl.textContent = `
        text { font-family: Verdana, sans-serif; font-size: 12px; }
        text.outside-label { font-size: 12px; dominant-baseline: middle; }
        text.col-heading { font-size: 12px; font-weight: 700; }
      `;
      svgElClone.insertBefore(styleEl, svgElClone.firstChild);
    }

    // Export: numbers on own line for all labels EXCEPT Verkauft/Zugekauft ("right_divested")
    function addNumbersToClonedSVG(svgElClone) {
      const labelTexts = svgElClone.querySelectorAll("text.outside-label");

      labelTexts.forEach(t => {
        const name = t.getAttribute("data-name");
        const displayVal = Math.abs(Number(t.getAttribute("data-display")));

        const tspans = Array.from(t.querySelectorAll("tspan"));
        if (tspans.length === 0) return;

        const last = tspans[tspans.length - 1];
        const x = last.getAttribute("x") || tspans[0].getAttribute("x") || "0";

        const oneLine = (name === "right_divested"); // Verkauft/Zugekauft: one line

        if (oneLine) {
          last.textContent = `${last.textContent}: ${formatMio(displayVal)}`;
          return;
        }

        // add number on its own line (no colon)
        const tspanNum = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspanNum.setAttribute("x", x);
        tspanNum.setAttribute("dy", "1.15em");
        tspanNum.textContent = `${formatMio(displayVal)}`;
        t.appendChild(tspanNum);
      });
    }

    function serializeSVG(svgEl) {
      const serializer = new XMLSerializer();
      let source = serializer.serializeToString(svgEl);

      if (!source.match(/^<svg[^>]+xmlns=/)) {
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
      }
      if (!source.match(/^<svg[^>]+"http:\/\/www.w3.org\/1999\/xlink"/)) {
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
      }
      return source;
    }

    function downloadSVGWithNumbers(filename) {
      const svgEl = d3.select("#chart").select("svg").node();
      const clone = svgEl.cloneNode(true);

      const vb = svgEl.viewBox && svgEl.viewBox.baseVal ? svgEl.viewBox.baseVal : null;
      if (vb) {
        clone.setAttribute("width", vb.width);
        clone.setAttribute("height", vb.height);
      }

      injectExportStyles(clone);
      addNumbersToClonedSVG(clone);

      const source = serializeSVG(clone);
      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      downloadBlob(blob, filename);
    }

    function downloadPNGWithNumbers(filename, scale = 4) {
      const svgEl = d3.select("#chart").select("svg").node();
      const clone = svgEl.cloneNode(true);

      const vb = svgEl.viewBox && svgEl.viewBox.baseVal ? svgEl.viewBox.baseVal : null;
      const w = vb ? vb.width : fullW;
      const h = vb ? vb.height : fullH;

      clone.setAttribute("width", w);
      clone.setAttribute("height", h);

      injectExportStyles(clone);
      addNumbersToClonedSVG(clone);

      const svgString = serializeSVG(clone);
      const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = Math.round(w * scale);
        canvas.height = Math.round(h * scale);

        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        canvas.toBlob(blob => {
          downloadBlob(blob, filename);
          URL.revokeObjectURL(url);
        }, "image/png");
      };

      img.onerror = (e) => {
        console.error("PNG export failed", e);
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }

    // ---------- wire up ----------
    d3.select("#amSelect").on("change", function() {
      loadChart(this.value);
    });

    document.getElementById("btnSvg").addEventListener("click", () => {
      downloadSVGWithNumbers(`sankey_${currentPrefix}.svg`);
    });

    document.getElementById("btnPng").addEventListener("click", () => {
      downloadPNGWithNumbers(`sankey_${currentPrefix}.png`, 4);
    });

    // initial draw
    loadChart(d3.select("#amSelect").property("value"));
  </script>
</body>
</html>
